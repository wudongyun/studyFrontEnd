; 对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性。

; 计算属性的用法
computed: {
    // 计算属性的 getter
    publishedBooksMessage() {
      // `this` 指向 vm 实例
      return this.author.books.length > 0 ? 'Yes' : 'No'
    }
  }

这样看来，计算属性跟method的得到的效果一样
为何会有computed属性呢？

; 计算属性缓存和方法
我们可以将同样的函数定义为一个方法，而不是一个计算属性。从最终结果来说，这两种实现方式确实是完全相同的。然而，不同的是计算属性将基于它们的响应依赖关系缓存。计算属性只会在相关响应式依赖发生改变时重新求值。这就意味着只要 author.books 还没有发生改变，多次访问 publishedBookMessage 时计算属性会立即返回之前的计算结果，而不必再次执行函数。

这也同样意味着下面的计算属性将永远不会更新，因为 Date.now () 不是响应式依赖：

computed: {
  now() {
    return Date.now()
  }
}
相比之下，每当触发重新渲染时，调用方法将始终会再次执行函数。

我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 list，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 list。如果没有缓存，我们将不可避免的多次执行 list 的 getter！如果你不希望有缓存，请用 method 来替代。

#计算属性的 Setter
计算属性默认只有getter，不过也可以提供需要的setter

